!function r(a,s,l){function h(n,e){if(!s[n]){if(!a[n]){var t="function"==typeof require&&require;if(!e&&t)return t(n,!0);if(p)return p(n,!0);var i=new Error("Cannot find module '"+n+"'");throw i.code="MODULE_NOT_FOUND",i}var o=s[n]={exports:{}};a[n][0].call(o.exports,function(e){var t=a[n][1][e];return h(t||e)},o,o.exports,r,a,s,l)}return s[n].exports}for(var p="function"==typeof require&&require,e=0;e<l.length;e++)h(l[e]);return h}({1:[function(e,t,n){t.exports=function(e){"string"==typeof e&&(e=[e]);for(var t=[].slice.call(arguments,1),n=[],i=0;i<e.length-1;i++)n.push(e[i],t[i]||"");return n.push(e[i]),n.join("")}},{}],2:[function(e,t,n){"use strict";Object.defineProperty(n,"__esModule",{value:!0});var i=function(){function i(e,t){for(var n=0;n<t.length;n++){var i=t[n];i.enumerable=i.enumerable||!1,i.configurable=!0,"value"in i&&(i.writable=!0),Object.defineProperty(e,i.key,i)}}return function(e,t,n){return t&&i(e.prototype,t),n&&i(e,n),e}}();var r=e("glslify"),o=function(){function e(){!function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,e)}return i(e,[{key:"setMeshScalar",value:function(e){this.meshScalar=e}},{key:"buildGeometry",value:function(){var e=this.props.textureWidth/this.meshScalar+1,t=this.props.textureHeight/this.meshScalar+1,n=new THREE.Vector2(this.meshScalar/this.props.textureWidth,this.meshScalar/this.props.textureHeight);this.geometry=new THREE.Geometry;for(var i=0;i<t;i++)for(var o=0;o<e;o++)this.geometry.vertices.push(new THREE.Vector3(o*n.x,i*n.y,0));for(var r=0;r<t-1;r++)for(var a=0;a<e-1;a++)this.geometry.faces.push(new THREE.Face3(a+r*e,a+(r+1)*e,a+1+r*e)),this.geometry.faces.push(new THREE.Face3(a+1+r*e,a+(r+1)*e,a+1+(r+1)*e));this.mesh=new THREE.Mesh(this.geometry,this.material)}},{key:"buildMaterial",value:function(){var e=r(["#extension GL_OES_standard_derivatives : enable\n#define GLSLIFY 1\n\nuniform sampler2D map;\nuniform float opacity;\nuniform float width;\nuniform float height;\n\nvarying vec2 vUv;\nvarying vec2 vUvDepth;\nvarying vec4 vPos;\nfloat _DepthBrightnessThreshold = 0.8;  // per-pixel brightness threshold, used to refine edge geometry from eroneous edge depth samples\nfloat _SheerAngleThreshold = 0.0001;       // per-pixel internal edge threshold (sheer angle of geometry at that pixel)\n#define BRIGHTNESS_THRESHOLD_OFFSET 0.01\n#define FLOAT_EPS 0.00001\n#define CLIP_EPSILON 0.005\n\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n    float d = q.x - min(q.w, q.y);\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + FLOAT_EPS)), d / (q.x + FLOAT_EPS), q.x);\n}\n\nfloat depthForPoint(vec2 texturePoint)\n{   \n    vec2 centerpix = vec2(.5/width, .5/height);\n    texturePoint += centerpix;\n    // clamp to texture bounds - 0.5 pixelsize so we do not sample outside our texture\n    texturePoint = clamp(texturePoint, centerpix, vec2(1.0, 0.5) - centerpix);\n    vec4 depthsample = texture2D(map, texturePoint);\n    vec3 depthsamplehsv = rgb2hsv(depthsample.rgb);\n    return depthsamplehsv.b > _DepthBrightnessThreshold + BRIGHTNESS_THRESHOLD_OFFSET ? depthsamplehsv.r : 0.0;\n}\n\nvoid main()\n{\n    vec2 centerpix = vec2(.5/width, .5/height);\n    vec2 centerDepthSampleCoord = vUvDepth - mod(vUvDepth, vec2(1.0/width, 1.0/height) ); // clamp to start of pixel\n\n    float depth = depthForPoint(centerDepthSampleCoord);\n    // we filter the _SheerAngleThreshold value on CPU so that we have an ease in over the 0..1 range, removing internal geometry at grazing angles\n    // we also apply near and far clip clipping, the far clipping plane is pulled back to remove geometry wrapped to the far plane from the near plane\n    //convert back from worldspace to local space\n    vec4 localPos = vPos;\n    //convert to homogenous coordinate space\n    localPos.xy /= localPos.z;\n    //find local space normal for triangle surface\n    vec3 dx = dFdx(localPos.xyz);\n    vec3 dy = dFdy(localPos.xyz);\n    vec3 n = normalize(cross(dx, dy));\n    \n    // make sure to handle dot product of the whole hemisphere by taking the absolute of range -1 to 0 to 1\n    float sheerAngle = abs(dot(n, vec3(0.0, 0.0, 1.0)));\n\n    // clamp to texture bounds - 0.5 pixelsize so we do not sample outside our texture\n    vec2 colorTexCoord = clamp(vUv, vec2(0.0, 0.5) + centerpix, vec2(1.0, 1.0) - centerpix);\n    vec4 color = texture2D(map, colorTexCoord);\n    color.w = opacity;\n\n    //color.xyz = vPos.xyz * 0.5 + 0.5;\n    //color.xyz = n.xyz * 0.5 + 0.5;\n    //color.xyz = vec3(sheerAngle, sheerAngle, sheerAngle);\n\n    if ( depth <        CLIP_EPSILON  ||\n         depth > (1.0 - CLIP_EPSILON) ||\n         sheerAngle < (_SheerAngleThreshold + FLOAT_EPS))\n    {\n        discard;\n    }\n\n    gl_FragColor = color;\n}"]),t=r(["#define GLSLIFY 1\nuniform float nearClip;\nuniform float farClip;\nuniform float width;\nuniform float height;\nuniform bool isPoints;\nuniform float pointSize;\nuniform float time;\nuniform vec2 focalLength;\nuniform vec2 principalPoint;\nuniform vec2 imageDimensions;\nuniform vec4 crop;\nuniform float meshScalar;\nuniform mat4 extrinsics;\nuniform sampler2D map;\nvarying vec4 vPos;\nvarying vec2 vUv;\nvarying vec2 vUvDepth;\n\nfloat _DepthBrightnessThreshold = 0.5;  // per-pixel brightness threshold, used to refine edge geometry from eroneous edge depth samples\n#define BRIGHTNESS_THRESHOLD_OFFSET 0.01\n#define FLOAT_EPS 0.00001\n#define CLIP_EPSILON 0.005\n\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n    float d = q.x - min(q.w, q.y);\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + FLOAT_EPS)), d / (q.x + FLOAT_EPS), q.x);\n}\n\nfloat depthForPoint(vec2 texturePoint)\n{   \n    vec2 centerpix = vec2(1.0/width, 1.0/height) * 0.5;\n    texturePoint += centerpix;\n\n    // clamp to texture bounds - 0.5 pixelsize so we do not sample outside our texture\n    texturePoint = clamp(texturePoint, centerpix, vec2(1.0, 0.5) - centerpix);\n    vec4 depthsample = texture2D(map, texturePoint);\n    vec3 depthsamplehsv = rgb2hsv(depthsample.rgb);\n    return depthsamplehsv.b > _DepthBrightnessThreshold + BRIGHTNESS_THRESHOLD_OFFSET ? depthsamplehsv.r : 0.0;\n}\n\nvoid main()\n{\n    vec4 texSize = vec4(1.0 / width, 1.0 / height, width, height);\n    vec2 basetex = position.xy;\n\n    // we align our depth pixel centers with the center of each quad, so we do not require a half pixel offset\n    vec2 depthTexCoord = basetex * vec2(1.0, 0.5);\n    vec2 colorTexCoord = basetex * vec2(1.0, 0.5) + vec2(0.0, 0.5);\n\n    // coordinates are always aligned to a multiple of texture sample widths, no need to clamp to topleft\n    // unlike per-pixel sampling.\n    float depth = depthForPoint(depthTexCoord);\n    if (depth <= CLIP_EPSILON || ((1.0 - CLIP_EPSILON) >= depth))\n    {\n        // we use a 3x3 kernel, so sampling 8 neighbors\n        //vec2 textureStep = 1.0 / meshScalar;\n        vec2 textureStep = vec2(texSize.x * meshScalar, texSize.y * meshScalar);   // modify our texture step \n        \n        vec2 neighbors[8];\n        neighbors[0] = vec2(-textureStep.x, -textureStep.y);\n        neighbors[1] = vec2(0, -textureStep.y);\n        neighbors[2] = vec2(textureStep.x, -textureStep.y);\n        neighbors[3] = vec2(-textureStep.x, 0);\n        neighbors[4] = vec2(textureStep.x, 0);\n        neighbors[5] = vec2(-textureStep.x, textureStep.y);\n        neighbors[6] = vec2(0, textureStep.y);\n        neighbors[7] = vec2(textureStep.x, textureStep.y);\n        \n        // if this depth sample is not valid then check neighbors\n        int validNeighbors = 0;\n        float maxDepth = 0.0;\n        for (int i = 0; i < 8; i++)\n        {\n            float depthNeighbor = depthForPoint(depthTexCoord + neighbors[i]);\n            maxDepth = max(maxDepth, depthNeighbor);\n            validNeighbors += (depthNeighbor > CLIP_EPSILON || ((1.0 - CLIP_EPSILON) < depthNeighbor)) ? 1 : 0;\n        }\n\n        // clip to near plane if we and all our neighbors are invalid\n        depth = validNeighbors > 0 ? maxDepth : 0.0;\n    }\n\n    vec2 imageCoordinates = crop.xy + (basetex * crop.zw);\n    float z = depth * (farClip - nearClip) + nearClip; // transform from 0..1 space to near-far space Z\n    vec2 ortho = imageCoordinates * imageDimensions - principalPoint;\n    vec2 proj = ortho * z / focalLength;\n    vec4 worldPos = extrinsics *  vec4(proj.xy, z, 1.0);\n    worldPos.w = 1.0;\n    gl_Position =  projectionMatrix * modelViewMatrix * worldPos;\n    vUv = colorTexCoord;\n    vUvDepth = depthTexCoord;\n    vPos = worldPos;//gl_Position.xyz;//(modelMatrix * vec4(gl_Position.xyz, 1.0)).xyz;//(modelMatrix * vec4(position, 1.0)).xyz;\n}\n"]),n=new THREE.Matrix4,i=this.props.extrinsics;n.set(i.e00,i.e10,i.e20,i.e30,i.e01,i.e11,i.e21,i.e31,i.e02,i.e12,i.e22,i.e32,i.e03,i.e13,i.e23,i.e33);var o=new THREE.Matrix4;o.getInverse(n),this.material=new THREE.ShaderMaterial({uniforms:{map:{type:"t",value:this.videoTexture},time:{type:"f",value:0},nearClip:{type:"f",value:this.props.nearClip},farClip:{type:"f",value:this.props.farClip},meshScalar:{type:"f",value:this.meshScalar},focalLength:{value:this.props.depthFocalLength},principalPoint:{value:this.props.depthPrincipalPoint},imageDimensions:{value:this.props.depthImageSize},extrinsics:{value:n},extrinsicsInv:{value:o},crop:{value:this.props.crop},width:{type:"f",value:this.props.textureWidth},height:{type:"f",value:this.props.textureHeight},opacity:{type:"f",value:1}},vertexShader:t,fragmentShader:e,transparent:!0}),this.material.side=THREE.DoubleSide}},{key:"load",value:function(e,t,n){var i=this;this.video=document.createElement("video"),this.video.id="depthkit-video",this.video.crossOrigin="anonymous",this.video.setAttribute("crossorigin","anonymous"),this.video.setAttribute("webkit-playsinline","webkit-playsinline"),this.video.setAttribute("playsinline","playsinline"),this.video.src=t,this.video.autoplay=!1,this.video.loop=!1,this.video.load(),this.videoTexture=new THREE.VideoTexture(this.video),this.videoTexture.minFilter=THREE.NearestFilter,this.videoTexture.magFilter=THREE.LinearFilter,this.videoTexture.format=THREE.RGBFormat,this.videoTexture.generateMipmaps=!1,this.manager=new THREE.LoadingManager,this.meshScalar||(this.meshScalar=2),this.jsonLoader=new THREE.FileLoader(this.manager),this.jsonLoader.setResponseType("json"),this.jsonLoader.load(e,function(e){i.props=e,i.buildMaterial(),i.buildGeometry(),i.mesh.frustumCulled=!1,(i.mesh.depthkit=i).mesh.name="depthkit",n&&n(i.mesh)})}},{key:"setPointSize",value:function(e){this.material.uniforms.isPoints.value?this.material.uniforms.pointSize.value=e:console.warn("Can not set point size because the current character is not set to render points")}},{key:"setOpacity",value:function(e){this.material.uniforms.opacity.value=e}},{key:"setLineWidth",value:function(e){this.material.wireframe?this.material.wireframeLinewidth=e:console.warn("Can not set the line width because the current character is not set to render wireframe")}},{key:"play",value:function(){this.video.isPlaying?console.warn("Can not play because the character is already playing"):this.video.play()}},{key:"stop",value:function(){this.video.currentTime=0,this.video.pause()}},{key:"pause",value:function(){this.video.pause()}},{key:"setLoop",value:function(e){this.video.loop=e}},{key:"setVolume",value:function(e){this.video.volume=e}},{key:"update",value:function(e){this.material.uniforms.time.value=e}},{key:"toggleColliderVisiblity",value:function(){this.mesh.collider.visible=!this.mesh.collider.visible}},{key:"dispose",value:function(){try{this.mesh.parent.remove(this.mesh)}catch(e){console.warn(e)}finally{this.mesh.traverse(function(e){void 0!==e.geometry&&(e.geometry.dispose(),e.material.dispose())})}}}]),e}();n.default=o},{glslify:1}],3:[function(e,t,n){"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.DepthKit=void 0;var i,o="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e},r=e("./depthkit"),a=(i=r)&&i.__esModule?i:{default:i};"undefined"!=typeof window&&"object"===o(window.THREE)?window.DepthKit=a.default:console.warn("[DepthKit.js] It seems like THREE is not included in your code, try including it before DepthKit.js"),n.DepthKit=a.default},{"./depthkit":2}]},{},[3]);
